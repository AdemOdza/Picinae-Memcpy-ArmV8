\documentclass[a4paper,12pt]{report}
%%%%%%%%%%%%
% Template %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% We used the Sleek Template by François Rozet             %
% Link: https://github.com/francois-rozet/sleek-template   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%
% Packages %
%%%%%%%%%%%%

\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{packages/sleek}
\usepackage{packages/sleek-title}
\usepackage{packages/sleek-theorems}
\usepackage{packages/sleek-listings}

%%%%%%%%%%%%%%
% Title-page %
%%%%%%%%%%%%%%

\logo{./resources/pdf/utd.png}
\institute{CS 6335 -- Language-Based Security}
\faculty{Dr. Kevin Hamlen}
%\department{Department of Anything but Psychology}
\title{A Functional Correctness Proof for $memcpy$}
\subtitle{Adem Odza, Avery Arnold, Dagmawet Zemedkun, Omar Khan, Fatema Tuj Johora}
\author{\textit{Author}\\François \textsc{Rozet}}
%\supervisor{Linus \textsc{Torvalds}}
%\context{A long time ago in a galaxy far, far away...}
\date{December 16, 2025}

%%%%%%%%%%%%%%%%
% Bibliography %
%%%%%%%%%%%%%%%%

\addbibresource{./resources/bib/references.bib}

%%%%%%%%%%
% Macros %
%%%%%%%%%%

\def\tbs{\textbackslash}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%




\begin{document}
    \maketitle

    \clearpage
    \pagenumbering{roman}
    \tableofcontents
    \clearpage
    \pagenumbering{arabic}

    \chapter{Introduction}
    Our group worked on partially proving the correctness of the $memcpy$ function in the MUSL library. 
    The $memcpy$ function copies a number of bytes from one section of memory to another. 
    % All code pulled from here: https://git.musl-libc.org/cgit/musl/tree/src/string/memcpy.c%
    \begin{figure}[hbtp]
        \lstset{
        numbers=left, 
        firstnumber=1,
        numberfirstline=true
        }
        \caption{The $memcpy$ function header}
        \label{code.1}
        \begin{lstlisting}[language=c,frame=single]
            #include <string.h>
            #include <stdint.h>
            #include <endian.h>

            void *memcpy(void *restrict dest, const void *restrict src, size_t n)
            {
                unsigned char *d = dest;
                const unsigned char *s = src;

            #ifdef __GNUC__

            #if __BYTE_ORDER == __LITTLE_ENDIAN
            #define LS >>
            #define RS <<
            #else
            #define LS <<
            #define RS >>
            #endif

                typedef uint32_t __attribute__((__may_alias__)) u32;
                uint32_t w, x;

                for (; (uintptr_t)s % 4 && n; n--) *d++ = *s++;
            ...
        \end{lstlisting}
    \end{figure}

    In figure $1.1$, we see the header of the $memcpy$ function. Three parameters are required: 
    the $dest$ pointer where the data will be copied to, 
    the $src$ pointer where the data will be copied from, 
    and the $size\_t$ $n$ which will contain the amount of bytes to copy. 
    Some preprocessor directives are also used to define the bit shift operators depending on the endianess of the system. 
    Line $23$ handles the case where the pointer is misaligned from the word boundary. 
    It copies byte-by-byte until the source pointer is aligned with the word boundary.



    % n between 16 and 32 %
        \begin{figure}[hbtp]
        \lstset{
        numbers=left, 
        firstnumber=25,
        numberfirstline=true
        }
        \caption{Copying 16 to 32 bytes}
        \label{code.1}
        \begin{lstlisting}[language=c,frame=single]
        if ((uintptr_t)d % 4 == 0) {
            for (; n>=16; s+=16, d+=16, n-=16) {
                *(u32 *)(d+0) = *(u32 *)(s+0);
                *(u32 *)(d+4) = *(u32 *)(s+4);
                *(u32 *)(d+8) = *(u32 *)(s+8);
                *(u32 *)(d+12) = *(u32 *)(s+12);
            }
            if (n&8) {
                *(u32 *)(d+0) = *(u32 *)(s+0);
                *(u32 *)(d+4) = *(u32 *)(s+4);
                d += 8; s += 8;
            }
            if (n&4) {
                *(u32 *)(d+0) = *(u32 *)(s+0);
                d += 4; s += 4;
            }
            if (n&2) {
                *d++ = *s++; *d++ = *s++;
            }
            if (n&1) {
                *d = *s;
            }
            return dest;
        }
            ...
        \end{lstlisting}
    \end{figure}
    The segment of code shown in figure $1.2$ handles the copying of bytes when $n >= 16$. 
    $16$ byte chunks are copied over until we have less than $16$ to copy. At that point, the remaining if statements copy the leftover bytes.



    \clearpage
    \chapter{Technical Approach}
        For our proof, we took a lot of inspiration from the proof of the $memset$ function. 
    There is one key difference in the behavior of the two function: $memset$ sets all modified bytes to the same value (Which is provided by the user) while $memcpy$ will set bytes to the corresponding value at the provided source pointer.
    This similarity allowed for us to create modified versions of the $memset$ definitions and apply them to our proof. \\


    The first step in our proof was to create some definitions for certain properties of $memcpy$. \\
    We created the $filled$ definition to represent the modified memory: 
    \begin{lstlisting}
        Definition filled m dest src len :=
            N.recursion m (fun i m' => m'[(B) dest + i := m (B)[src + i]]) len.
    \end{lstlisting}
    This definition states that a memory filled with $len$ bytes means that the $len$ bytes starting at $dest$ and $src$ have the same values. \\

    In the invariants section, we defined a few variables:
    \begin{lstlisting}
    Section Invariants.
        Variable mem : memory    (* initial memory state *).

        Variable dest : N
        Variable src : N 
        Variable len : N
    \end{lstlisting} 
    The first variable $mem$ represents the memory state and the rest represent the parameters to the $memcpy$ function. 
    The $dest$ variable holds the address to the section of memory that will be written to, 
    while $src$ holds the address to the section of memory that bytes will be copied from.
    The $len$ variable specifies the amount of bytes to copy. \\
    
    We also defined a function in the invariant section that returned the intended memory and register state of the function:
    \begin{lstlisting}
    (* Registers state after copying k bytes *)
    Definition memcpy_regs (s : store) k :=
        s V_MEM64 = filled mem dest src k /\
        s R_X0 = dest /\
        s R_X1 = src /\
        s R_X2 = (len - k).
    \end{lstlisting}
    This definition allows us to create an invariant at any point in the function, including during any loop iteration.
    The value $k$ represents the current progress of the function. 
    If $k$ out of $len$ bytes have been filled, then we expect the memory to match the $k$ filled state. 
    We also expect the $R_X2$ register to have $k$ less than its initial state as the function will subtract from this value to track progress.\\

    Next, we created the invariants so that we could begin our proof.
    \begin{lstlisting}
    Definition memcpy_invset' (t : trace) : option Prop :=
        match t with
        | (Addr a, s) :: _ =>
            match a with

            (* Entry point *)
            | 0x100000 => Some (memcpy_regs s 0)

            (* Loop 1 (1-byte writes to word boundary) *)
            | 0x100130 => Some (exists mem k, s V_MEM64 = filled mem dest src k)

            (* post-condition: *)
            | 0x100188 
            | 0x1000f8 
            | 0x100088 
            | 0x100064 
            | 0x100048 
            | 0x100030 
            | 0x1000b8 => Some (exists mem, s V_MEM64 = filled mem dest src len)

            | _ => None
            end
        | _ => None
        end.
    \end{lstlisting}
    The entry point invariant states that the memory should be unmodified as it should match a $filled \: mem \: dest \: src \: 0$ memory state.

    We place the loop invariant where we enter the loop at address $0x100130$. This loop invariant states that for every iteration of the loop, 
    there exists a memory state $mem$ and a value $k$ where the current memory state matches $filled \: mem \: dest \: src \: k$. That is, every loop iteration
    should match the previous one with an extra byte added from the $src$ to the $dest$ pointer. 

    The final invariant states that the memory state should equal a fully filled memory state ($filled \: mem \: dest \: src \: len$). All $len$ bytes at the $src$ address
    should have been copied to the memory at $dest$. 


    \clearpage

    \chapter{Team Organization}
    Our team consists of 5 people: 
    \begin{itemize}
        \item Adem Odza 
        \item \subitem Created presentation slides, gave presentation, 
        \item Avery Arnold
        \item Dagmawet Zemedkun
        \item Omar Khan
        \item Fatema Tuj Johora
    \end{itemize}


    \clearpage

    \chapter{Evaluation}

    \clearpage

    \chapter{Future Work}
    There are many additions to the proof that could be worked on.

    More properties of $memcpy$ could also be proved.

    Safety properties
    \clearpage

    \chapter{Related Work}
    memset

    \clearpage
\end{document}
