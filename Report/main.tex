\documentclass[a4paper,12pt]{report}
%%%%%%%%%%%%
% Template %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% We used the Sleek Template by Fran√ßois Rozet             %
% Link: https://github.com/francois-rozet/sleek-template   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%
% Packages %
%%%%%%%%%%%%

\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{packages/sleek}
\usepackage{packages/sleek-title}
\usepackage{packages/sleek-theorems}
\usepackage{packages/sleek-listings}

%%%%%%%%%%%%%%
% Title-page %
%%%%%%%%%%%%%%

\logo{./resources/pdf/utd.png}
\institute{CS 6335 -- Language-Based Security}
\faculty{Dr. Kevin Hamlen}
%\department{Department of Anything but Psychology}
\title{A Functional Correctness Proof for $memcpy$}
\subtitle{Adem Odza, Avery Arnold, Dagmawet Zemedkun, Omar Khan, Fatema Tuj Johora}
%\supervisor{Linus \textsc{Torvalds}}
%\context{A long time ago in a galaxy far, far away...}
\date{December 16, 2025}

%%%%%%%%%%%%%%%%
% Bibliography %
%%%%%%%%%%%%%%%%

\addbibresource{./resources/bib/references.bib}

%%%%%%%%%%
% Macros %
%%%%%%%%%%

\def\tbs{\textbackslash}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\lstset{
    backgroundcolor=\color{lightgray!20}, % optional: add background color
    frame=single,                          % adds a box around the code
    basicstyle=\ttfamily,                  % code font
    breaklines=true                        % wrap long lines
}


\begin{document}
    \maketitle

    \clearpage
    \pagenumbering{roman}
    \tableofcontents
    \clearpage
    \pagenumbering{arabic}

    \chapter{Introduction}
    Our group worked on partially proving the correctness of the $memcpy$ function in the MUSL library. 
    The $memcpy$ function copies a number of bytes from one section of memory to another. 
    % All code pulled from here: https://git.musl-libc.org/cgit/musl/tree/src/string/memcpy.c%
    \begin{figure}[hbtp]
        \lstset{
        numbers=left, 
        firstnumber=1,
        numberfirstline=true
        }
        \begin{lstlisting}[language=c,frame=single]
        #include <string.h>
        #include <stdint.h>
        #include <endian.h>

        void *memcpy(void *restrict dest, const void *restrict src, size_t n)
        {
                unsigned char *d = dest;
                const unsigned char *s = src;

            #ifdef __GNUC__

            #if __BYTE_ORDER == __LITTLE_ENDIAN
            #define LS >>
            #define RS <<
            #else
            #define LS <<
            #define RS >>
            #endif

                typedef uint32_t __attribute__((__may_alias__)) u32;
                uint32_t w, x;

                for (; (uintptr_t)s % 4 && n; n--) *d++ = *s++;
            ...
        \end{lstlisting}
        \caption{The $memcpy$ function header}
        \label{code.1}
    \end{figure}
    

    In figure $1.1$, we see the header of the $memcpy$ function. Three parameters are required: 
    the $dest$ pointer where the data will be copied to, 
    the $src$ pointer where the data will be copied from, 
    and the $size\_t$ $n$ which will contain the amount of bytes to copy. 
    Some preprocessor directives are also used to define the bit shift operators depending on the endianess of the system. 
    Line $23$ handles the case where the pointer is misaligned from the word boundary. 
    It copies byte-by-byte until the source pointer is aligned with the word boundary.



    % n between 16 and 32 %
        \begin{figure}[hbtp]
        \lstset{
        numbers=left, 
        firstnumber=25,
        numberfirstline=true
        }
        \begin{lstlisting}[language=c,frame=single]
        if ((uintptr_t)d % 4 == 0) {
            for (; n>=16; s+=16, d+=16, n-=16) {
                *(u32 *)(d+0) = *(u32 *)(s+0);
                *(u32 *)(d+4) = *(u32 *)(s+4);
                *(u32 *)(d+8) = *(u32 *)(s+8);
                *(u32 *)(d+12) = *(u32 *)(s+12);
            }
            if (n&8) {
                *(u32 *)(d+0) = *(u32 *)(s+0);
                *(u32 *)(d+4) = *(u32 *)(s+4);
                d += 8; s += 8;
            }
            if (n&4) {
                *(u32 *)(d+0) = *(u32 *)(s+0);
                d += 4; s += 4;
            }
            if (n&2) {
                *d++ = *s++; *d++ = *s++;
            }
            if (n&1) {
                *d = *s;
            }
            return dest;
        }
            ...
        \end{lstlisting}
        \caption{Copying 16 to 32 bytes}
        \label{code.2}
    \end{figure}
    The segment of code shown in figure $1.2$ handles the copying of bytes when $n >= 16$. 
    $16$ byte chunks are copied over until we have less than $16$ to copy. At that point, the remaining if statements copy the leftover bytes. \\

    % n greater than 32 %
        \begin{figure}[hbtp]
        \lstset{
        numbers=left, 
        firstnumber=50,
        numberfirstline=true
        }
        \begin{lstlisting}[language=c,frame=single]
        if (n >= 32) switch ((uintptr_t)d % 4) {
	case 1:
		w = *(u32 *)s;
		*d++ = *s++;
		*d++ = *s++;
		*d++ = *s++;
		n -= 3;
		for (; n>=17; s+=16, d+=16, n-=16) {
			x = *(u32 *)(s+1);
			*(u32 *)(d+0) = (w LS 24) | (x RS 8);
			w = *(u32 *)(s+5);
			*(u32 *)(d+4) = (x LS 24) | (w RS 8);
			x = *(u32 *)(s+9);
			*(u32 *)(d+8) = (w LS 24) | (x RS 8);
			w = *(u32 *)(s+13);
			*(u32 *)(d+12) = (x LS 24) | (w RS 8);
		}
		break;
	case 2:
		w = *(u32 *)s;
		*d++ = *s++;
		*d++ = *s++;
		n -= 2;
		for (; n>=18; s+=16, d+=16, n-=16) {
			x = *(u32 *)(s+2);
			*(u32 *)(d+0) = (w LS 16) | (x RS 16);
			w = *(u32 *)(s+6);
			*(u32 *)(d+4) = (x LS 16) | (w RS 16);
			x = *(u32 *)(s+10);
			*(u32 *)(d+8) = (w LS 16) | (x RS 16);
			w = *(u32 *)(s+14);
			*(u32 *)(d+12) = (x LS 16) | (w RS 16);
		}
		break;
	case 3:
		w = *(u32 *)s;
		*d++ = *s++;
		n -= 1;
		for (; n>=19; s+=16, d+=16, n-=16) {
			x = *(u32 *)(s+3);
			*(u32 *)(d+0) = (w LS 8) | (x RS 24);
			w = *(u32 *)(s+7);
			*(u32 *)(d+4) = (x LS 8) | (w RS 24);
			x = *(u32 *)(s+11);
			*(u32 *)(d+8) = (w LS 8) | (x RS 24);
			w = *(u32 *)(s+15);
			*(u32 *)(d+12) = (x LS 8) | (w RS 24);
		}
		break;
	}
        \end{lstlisting}
        \caption{Copying more than 32 bytes}
        \label{code.3}
    \end{figure}

    In the section of code shown in figure $1.3$, we once again copy 16 bytes at a time. Though, this time, we are handling the case where the destination pointer is not aligned to the word boundary.
    Depending on how many bytes are needed to reach the next word, we enter a different case in the switch statement. Each case then manually copies the bytes needed to reach the next byte boundary. Once that byte boundary is reached, we then copy bytes that are not aligned with the word boundaries. In the for loop, some bits are taken from the current word and the rest are taken from the next word (Depending on which case we are in, this value is different.) \\
    



    \clearpage
    \chapter{Technical Approach}
        For our proof, we took a lot of inspiration from the proof of the $memset$ function. 
    There is one key difference in the behavior of the two function: $memset$ sets all modified bytes to the same value (Which is provided by the user) while $memcpy$ will set bytes to the corresponding value at the provided source pointer.
    This similarity allowed for us to create modified versions of the $memset$ definitions and apply them to our proof. \\


    The first step in our proof was to create some definitions for certain properties of $memcpy$. \\
    We created the $filled$ definition to represent the modified memory: 
    \begin{lstlisting}
        Definition filled m dest src len :=
            N.recursion m (fun i m' => m'[(B) dest + i := m (B)[src + i]]) len.
    \end{lstlisting}
    This definition states that a memory filled with $len$ bytes means that the $len$ bytes starting at $dest$ and $src$ have the same values. \\

    In the invariants section, we defined a few variables:
    \begin{lstlisting}
    Section Invariants.
        Variable mem : memory    (* initial memory state *).

        Variable dest : N
        Variable src : N 
        Variable len : N
    \end{lstlisting} 
    The first variable $mem$ represents the memory state and the rest represent the parameters to the $memcpy$ function. 
    The $dest$ variable holds the address to the section of memory that will be written to, 
    while $src$ holds the address to the section of memory that bytes will be copied from.
    The $len$ variable specifies the amount of bytes to copy. \\
    
    We also defined a function in the invariant section that returned the intended memory and register state of the function:
    \begin{lstlisting}
    (* Registers state after copying k bytes *)
    Definition memcpy_regs (s : store) k :=
        s V_MEM64 = filled mem dest src k /\
        s R_X0 = dest /\
        s R_X1 = src /\
        s R_X2 = (len - k).
    \end{lstlisting}
    This definition allows us to create an invariant at any point in the function, including during any loop iteration.
    The value $k$ represents the current progress of the function. 
    If $k$ out of $len$ bytes have been filled, then we expect the memory to match the $k$ filled state. 
    We also expect the $R_X2$ register to have $k$ less than its initial state as the function will subtract from this value to track progress.\\

    Next, we created the invariants so that we could begin our proof.
    \begin{lstlisting}
    Definition memcpy_invset' (t : trace) : option Prop :=
        match t with
        | (Addr a, s) :: _ =>
            match a with

            (* Entry point *)
            | 0x100000 => Some (memcpy_regs s 0)

            (* Loop 1 (1-byte writes to word boundary) *)
            | 0x100130 => Some (exists mem k, s V_MEM64 = filled mem dest src k)

            (* post-condition: *)
            | 0x100188 
            | 0x1000f8 
            | 0x100088 
            | 0x100064 
            | 0x100048 
            | 0x100030 
            | 0x1000b8 => Some (exists mem, s V_MEM64 = filled mem dest src len)

            | _ => None
            end
        | _ => None
        end.
    \end{lstlisting}
    The entry point invariant states that the memory should be unmodified as it should match a $filled \: mem \: dest \: src \: 0$ memory state.

    We place the loop invariant where we enter the loop at address $0x100130$. This loop invariant states that for every iteration of the loop, 
    there exists a memory state $mem$ and a value $k$ where the current memory state matches $filled \: mem \: dest \: src \: k$. That is, every loop iteration
    should match the previous one with an extra byte added from the $src$ to the $dest$ pointer. 

    The final invariant states that the memory state should equal a fully filled memory state ($filled \: mem \: dest \: src \: len$). All $len$ bytes at the $src$ address
    should have been copied to the memory at $dest$. 


    \clearpage

    \chapter{Team Organization}
    Our team consists of 5 people: 
    \begin{itemize}
        \item Adem Odza 
        \item \subitem Created presentation slides, gave presentation, 
        \item Avery Arnold
        \item Dagmawet Zemedkun
        \item Omar Khan
        \item Fatema Tuj Johora
    \end{itemize}


    \clearpage

    \chapter{Evaluation}

    \clearpage

    \chapter{Future Work}
    There are many additions to the proof that could be worked on.

    More properties of $memcpy$ could also be proved.

    Safety properties
    \clearpage

    \chapter{Related Work}
    memset

    \clearpage
\end{document}