\documentclass[a4paper,12pt]{report}
%%%%%%%%%%%%
% Template %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% We used the Sleek Template by François Rozet             %
% Link: https://github.com/francois-rozet/sleek-template   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%
% Packages %
%%%%%%%%%%%%

\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{packages/sleek}
\usepackage{packages/sleek-title}
\usepackage{packages/sleek-theorems}
\usepackage{packages/sleek-listings}
\usepackage{enumitem}

%%%%%%%%%%%%%%
% Title-page %
%%%%%%%%%%%%%%

\logo{./resources/pdf/utd.png}
\institute{CS 6335 -- Language-Based Security}
\faculty{Dr. Kevin Hamlen}
%\department{Department of Anything but Psychology}
\title{A Functional Correctness Proof for $memcpy$}
\subtitle{Adem Odza, Avery Arnold, Dagmawet Zemedkun, Omar Khan, Fatema Tuj Johora}
%\supervisor{Linus \textsc{Torvalds}}
%\context{A long time ago in a galaxy far, far away...}
\date{December 16, 2025}

%%%%%%%%%%%%%%%%
% Bibliography %
%%%%%%%%%%%%%%%%

\addbibresource{./resources/bib/references.bib}

%%%%%%%%%%
% Macros %
%%%%%%%%%%

\def\tbs{\textbackslash}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\lstset{
    backgroundcolor=\color{lightgray!20}, % optional: add background color
    frame=single,                          % adds a box around the code
    basicstyle=\ttfamily,                  % code font
    breaklines=true                        % wrap long lines
}


\begin{document}
    \maketitle

    \clearpage
    \pagenumbering{roman}
    \tableofcontents
    \clearpage
    \pagenumbering{arabic}

    \chapter{Introduction}
    Our group worked on partially proving the correctness of the $memcpy$ function in the MUSL library. 
    The $memcpy$ function copies a number of bytes from one section of memory to another. 
    % All code pulled from here: https://git.musl-libc.org/cgit/musl/tree/src/string/memcpy.c%
    \begin{figure}[hbtp]
        \lstset{
        numbers=left, 
        firstnumber=1,
        numberfirstline=true
        }
        \begin{lstlisting}[language=c,frame=single]
        #include <string.h>
        #include <stdint.h>
        #include <endian.h>

        void *memcpy(void *restrict dest, const void *restrict src, size_t n)
        {
                unsigned char *d = dest;
                const unsigned char *s = src;

            #ifdef __GNUC__

            #if __BYTE_ORDER == __LITTLE_ENDIAN
            #define LS >>
            #define RS <<
            #else
            #define LS <<
            #define RS >>
            #endif

                typedef uint32_t __attribute__((__may_alias__)) u32;
                uint32_t w, x;

                for (; (uintptr_t)s % 4 && n; n--) *d++ = *s++;
            ...
        \end{lstlisting}
        \caption{The $memcpy$ function header}
        \label{code.1}
    \end{figure}
    

    In figure $1.1$, we see the header of the $memcpy$ function. Three parameters are required: 
    the $dest$ pointer where the data will be copied to, 
    the $src$ pointer where the data will be copied from, 
    and the $size\_t$ $n$ which will contain the amount of bytes to copy. 
    Some preprocessor directives are also used to define the bit shift operators depending on the endianess of the system. 
    Line $23$ handles the case where the pointer is misaligned from the word boundary. 
    It copies byte-by-byte until the source pointer is aligned with the word boundary.



    % n between 16 and 32 %
    \begin{figure}[hbtp]
        \lstset{
        numbers=left, 
        firstnumber=25,
        numberfirstline=true
        }
        \begin{lstlisting}[language=c,frame=single]
        if ((uintptr_t)d % 4 == 0) {
            for (; n>=16; s+=16, d+=16, n-=16) {
                *(u32 *)(d+0) = *(u32 *)(s+0);
                *(u32 *)(d+4) = *(u32 *)(s+4);
                *(u32 *)(d+8) = *(u32 *)(s+8);
                *(u32 *)(d+12) = *(u32 *)(s+12);
            }
            if (n&8) {
                *(u32 *)(d+0) = *(u32 *)(s+0);
                *(u32 *)(d+4) = *(u32 *)(s+4);
                d += 8; s += 8;
            }
            if (n&4) {
                *(u32 *)(d+0) = *(u32 *)(s+0);
                d += 4; s += 4;
            }
            if (n&2) {
                *d++ = *s++; *d++ = *s++;
            }
            if (n&1) {
                *d = *s;
            }
            return dest;
        }
            ...
        \end{lstlisting}
        \caption{Copying 16 to 32 bytes}
        \label{code.2}
    \end{figure}
    The segment of code shown in figure $1.2$ handles the copying of bytes when $n >= 16$. 
    $16$ byte chunks are copied over until we have less than $16$ to copy. At that point, the remaining if statements copy the leftover bytes. \\

    % n greater than 32 %
    \begin{figure}[hbtp]
        \lstset{
        numbers=left, 
        firstnumber=50,
        numberfirstline=true
        }
        \begin{lstlisting}[language=c,frame=single]
        if (n >= 32) switch ((uintptr_t)d % 4) {
	case 1:
		w = *(u32 *)s;
		*d++ = *s++;
		*d++ = *s++;
		*d++ = *s++;
		n -= 3;
		for (; n>=17; s+=16, d+=16, n-=16) {
			x = *(u32 *)(s+1);
			*(u32 *)(d+0) = (w LS 24) | (x RS 8);
			w = *(u32 *)(s+5);
			*(u32 *)(d+4) = (x LS 24) | (w RS 8);
			x = *(u32 *)(s+9);
			*(u32 *)(d+8) = (w LS 24) | (x RS 8);
			w = *(u32 *)(s+13);
			*(u32 *)(d+12) = (x LS 24) | (w RS 8);
		}
		break;
	case 2:
		w = *(u32 *)s;
		*d++ = *s++;
		*d++ = *s++;
		n -= 2;
		for (; n>=18; s+=16, d+=16, n-=16) {
			x = *(u32 *)(s+2);
			*(u32 *)(d+0) = (w LS 16) | (x RS 16);
			w = *(u32 *)(s+6);
			*(u32 *)(d+4) = (x LS 16) | (w RS 16);
			x = *(u32 *)(s+10);
			*(u32 *)(d+8) = (w LS 16) | (x RS 16);
			w = *(u32 *)(s+14);
			*(u32 *)(d+12) = (x LS 16) | (w RS 16);
		}
		break;
	case 3:
		w = *(u32 *)s;
		*d++ = *s++;
		n -= 1;
		for (; n>=19; s+=16, d+=16, n-=16) {
			x = *(u32 *)(s+3);
			*(u32 *)(d+0) = (w LS 8) | (x RS 24);
			w = *(u32 *)(s+7);
			*(u32 *)(d+4) = (x LS 8) | (w RS 24);
			x = *(u32 *)(s+11);
			*(u32 *)(d+8) = (w LS 8) | (x RS 24);
			w = *(u32 *)(s+15);
			*(u32 *)(d+12) = (x LS 8) | (w RS 24);
		}
		break;
	}
        \end{lstlisting}
        \caption{Copying more than 32 bytes}
        \label{code.4}
    \end{figure}

    In the section of code shown in figure $1.4$, we once again copy 16 bytes at a time. Though, this time, we are handling the case where the destination pointer is not aligned to the word boundary.
    Depending on how many bytes are needed to reach the next word, we enter a different case in the switch statement. Each case then manually copies the bytes needed to reach the next byte boundary. Once that byte boundary is reached, we then copy bytes that are not aligned with the word boundaries. In the for loop, some bits are taken from the current word and the rest are taken from the next word (Depending on which case we are in, this value is different.) \\
    
    \begin{figure}[hbtp]
        \lstset{
        numbers=left, 
        firstnumber=100,
        numberfirstline=true
        }
        \begin{lstlisting}[language=c,frame=single]
            if (n&16) {
                *d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
                *d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
                *d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
                *d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
            }
            if (n&8) {
                *d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
                *d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
            }
            if (n&4) {
                *d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
            }
            if (n&2) {
                *d++ = *s++; *d++ = *s++;
            }
            if (n&1) {
                *d = *s;
            }
            return dest;
        \end{lstlisting}
        \caption{Leftover bytes}
        \label{code.5}
    \end{figure}
    
    In figure $1.5$, the copying of any leftover bytes from the previous loops are handled. 



    % Final Bytes %
    \begin{figure}[hbtp]
        \lstset{
        numbers=left, 
        firstnumber=25,
        numberfirstline=true
        }
        \begin{lstlisting}[language=c,frame=single]
            for (; n; n--) *d++ = *s++;
	        return dest;
        \end{lstlisting}
        \caption{Copying for Non GNU Compiler}
        \label{code.4}
    \end{figure}
    Figure $1.4$ is only executed if the \verb|ifdef __GNUC__| preprocessor check passes. 
    Bytes are simply copied one by one using a for loop before the destination is returned.


    \clearpage
    
    \chapter{Motivation}
    Memcpy is a widely used function that is frequently associated with vulnerabilities such as return-oriented Programming and Buffer overflow attacks. 
    This function is dangerous to use because it does not validate buffer sizes. 
    Attackers can manipulate data in the overflowed areas on the stack to execute malicious code. 

    A famous case where memcpy played a role was in HeartBleed (CVE-2014-0160).
    A OpenSSL TLS heartbeat implementation, a user length form was trusted without validation. 
    This length was passed to memcpy without validation leading to attackers reading server memory in each request. 
    The unsafe use of memcpy in the Heartbeat handler caused an out-of-bounds memory read.  
    The impact of this catastrophe led to leakage of passwords and session cookies, ultimately affecting millions of servers worldwide. 
    This meant that authentication was breached and sensitive information was compromised. [1]

    Despite being associated with security vulnerabilities, memcpy is fundamental to modern computing systems.
    This function is used in operating systems, cryptography, and embedded systems.
    Also they are used in web servers and secure protocols for data movement.
    The important factor is secure usage of memcpy depends on bounds checking and defense programming because removing memcpy is impractical. 

    \clearpage
    
    \chapter{Technical Approach}
        For our proof, we took a lot of inspiration from the proof of the $memset$ function. 
    There is one key difference in the behavior of the two function: $memset$ sets all modified bytes to the same value (Which is provided by the user) while $memcpy$ will set bytes to the corresponding value at the provided source pointer.
    This similarity allowed for us to create modified versions of the $memset$ definitions and apply them to our proof. \\

    \section{Invariants}
    The first step in our proof was to create some definitions for certain properties of $memcpy$. \\
    We created the $filled$ definition to represent the modified memory: 
    \begin{lstlisting}
        Definition filled m dest src len :=
            N.recursion m (fun i m' => m'[(B) dest + i := m (B)[src + i]]) len.
    \end{lstlisting}
    This definition states that a memory filled with $len$ bytes means that the $len$ bytes starting at $dest$ and $src$ have the same values. \\

    In the invariants section, we defined a few variables:
    \begin{lstlisting}
    Section Invariants.
        Variable mem : memory    (* initial memory state *).

        Variable dest : N
        Variable src : N 
        Variable len : N
    \end{lstlisting} 
    The first variable $mem$ represents the memory state and the rest represent the parameters to the $memcpy$ function. 
    The $dest$ variable holds the address to the section of memory that will be written to, 
    while $src$ holds the address to the section of memory that bytes will be copied from.
    The $len$ variable specifies the amount of bytes to copy. \\
    
    We also defined a function in the invariant section that returned the intended memory and register state of the function:
    \begin{lstlisting}
    (* Registers state after copying k bytes *)
    Definition memcpy_regs (s : store) k :=
        s V_MEM64 = filled mem dest src k /\
        s R_X0 = dest /\
        s R_X1 = src /\
        s R_X2 = (len - k).
    \end{lstlisting}
    This definition allows us to create an invariant at any point in the function, including during any loop iteration.
    The value $k$ represents the current progress of the function. 
    If $k$ out of $len$ bytes have been filled, then we expect the memory to match the $k$ filled state. 
    We also expect the $R_X2$ register to have $k$ less than its initial state as the function will subtract from this value to track progress.\\

    Next, we created the invariants so that we could begin our proof.
    \begin{lstlisting}
    Definition memcpy_invset' (t : trace) : option Prop :=
        match t with
        | (Addr a, s) :: _ =>
            match a with

            (* Entry point *)
            | 0x100000 => Some (memcpy_regs s 0)

            (* Loop 1 (1-byte writes to word boundary) *)
            | 0x100130 => Some (exists mem k, s V_MEM64 = filled mem dest src k)

            (* post-condition: *)
            | 0x100188 
            | 0x1000f8 
            | 0x100088 
            | 0x100064 
            | 0x100048 
            | 0x100030 
            | 0x1000b8 => Some (exists mem, s V_MEM64 = filled mem dest src len)

            | _ => None
            end
        | _ => None
        end.
    \end{lstlisting}
    The entry point invariant states that the memory should be unmodified as it should match a $filled \: mem \: dest \: src \: 0$ memory state.

    We place the loop invariant where we enter the loop at address $0x100130$. This loop invariant states that for every iteration of the loop, 
    there exists a memory state $mem$ and a value $k$ where the current memory state matches $filled \: mem \: dest \: src \: k$. That is, every loop iteration
    should match the previous one with an extra byte added from the $src$ to the $dest$ pointer. 

    The final invariant states that the memory state should equal a fully filled memory state ($filled \: mem \: dest \: src \: len$). All $len$ bytes at the $src$ address
    should have been copied to the memory at $dest$. 
    

    \section{Control Flow}
    \includegraphics[width=\textwidth]{cfg_memcpy.png}

    Below we have included a summarized control flow diagram of our assembly program:
    \begin{itemize}
        \item $n$ more than $128$ bytes:
        \begin{itemize}
            \item Load data from the source at $16$ byte (Up to $64$) in intervals and store it in the corresponding location at the destination
            \item In each loop iteration:
            \begin{itemize}
                \item Copy 64 bytes 2 words at a time
                \item Subtract 64 from the remaining value in $R_{X0}$
                \item Once the remaining length is below $64$, break from the loop and copy the remaining bytes.
            \end{itemize}
        \end{itemize}
        \item It then checks $n > 32$:
        \begin{itemize}
            \item Then $n > 64$
            \item $n > 96$
            \begin{itemize}
                \item Copy the first $32$ bytes then fall through to the $64$ byte copy.
                \item If not, jump to the $64$ byte copy and copy the required bytes.
            \end{itemize}
            \item $n < 16$
            \begin{itemize}
                \item If not, copy the double word and return. 
            \end{itemize}
            \item $n < 8$
            \begin{itemize}
                \item If not, copy the double word and return. 
            \end{itemize}
            \item $n < 4$
            \begin{itemize}
                \item If $n < 4$, check bit values to determine length. Copy the remaining bytes and return. 
                \item Else, copy the remaining $4$ bytes. 
            \end{itemize}
        \end{itemize}
    \end{itemize}

    \section{Proof Strategy}
    Our general proof strategy is as follows:
    \begin{itemize}
        \item Lemmas involving the $filled$ definition
        \begin{itemize}
            \item $filled0$: copying $0$ bytes does not change memory
            \item $filled\_succ$: this lemma proves how to extend a memory copy by one additional byte. $k$ bytes plus an additional byte equals $k+1$ bytes copied.
            \item $filled\_add$: this follows similar logic to $filled\_succ$ but for $k+n$ bytes. This is solved through recursion on $n$.
            \item $filled1$: copying $1$ byte in filled is the same as copying $1$ byte from $src$ to $dst$
            \item $filled2$: copying $2$ byte in filled is the same as copying $2$ byte from $src$ to $dst$
            \item $filled3 / filled3\_pattern$:  expands $filled3$ into $3$ byte set updates
            \item $filled4, filled8, filled16$: helpful lemmas that are specialization of filled\_add, for $4$ bytes, etc. Simplify reasoning for writes of this size.
        \end{itemize}
        \item Byte-to-word Conversion: consecutive bytes can combined into word or quad word writes.
        \begin{itemize}
            \item four\_bytes\_to\_dword: four bytes, one after the other is equivalent to one dword writes.
            \begin{itemize}
                \item $filled \_4\_to\_dword$: four bytes can be covered by a dword. (write at $dest$)
                \item $filled \_5\_to\_dword$: five bytes span two overlapping dwords. (writes at $dest$ and $dest+1$)
                \item $filled \_6\_to\_dword$: six bytes span two overlapping dwords.  (writes at $dest$ and $dest+2$)
                \item $filled \_7\_to\_dword$: seven bytes span two overlapping dwords. (writes at $dest$ and $dest+3$)
                \item Other defined lemmas follow this pattern to reason about how our program writes small copies with overlapping dwords.
            \end{itemize}
            \item $filled\_8\_to\_qword$: follows similar logic. Eight consecutive bytes is equivalent to 1 qword.
            \item $filled\_32\_to\_4qwords$ and $filled\_64\_to\_8qwords$ follows similar logic.
        \end{itemize}
        \item Handling overlapping writes: We introduced lemmas to handle unaligned lengths. 
        Copies are handled by this method usually by copying the first bytes (head) and the last bytes (tail). 
        In the case of unaligned lengths, these writes can overlap. 
        The lemmas shows how byte writes of aligned writes plus overlapping tail word writes to prove that the resulting memory is equivalent. 
        \begin{itemize}
            \item $qword\_subsumes\_bytes\_tail$: last bytes of a sequence can be covered by one or more qword writes. qword(8bytes) at dest plus n bytes after it is the same as qword at dest  and qword at dest+n.
            \begin{itemize}
                \item We extend this logic into multiple lemmas reasoning about how this concept holds for different lengths.
            \end{itemize}
            \item $filled\_overlap methods$: replace sequences of bytes with the larger writes (either qwords or dword), while accounting for overlapping bytes using the previous lemma about how the tail bytes are covered for the with multiple writes.
            \begin{itemize}
                \item We use this logic to make a lemma for each possible byte path in our program.
            \end{itemize}
            \item $filled\_N\_toMqwords$: replace many byte-level updates with word-level writes at aligned offsets where $N$ is exact multiple of word size of no overlap.
            \begin{itemize}
                \item We reuse this logic creating multiple lemmas of different $N$ qwords consecutive writes.
            \end{itemize}
            \item $filled\_unaligned\_large$: large unaligned byte-level copy equals a small pattern of qwords writes plus bounded overlapping tail qwords.
            \item $two\_qword\_writes\_to\_filled$: fold 16 byte copy into two $8$ byte qword writes.
            \item $filled\_lt4$: copies small ($1$,$2$,or $3$) blocks from start, middle, and end (i.e. copying one-by-one).
        \end{itemize}
    \end{itemize}
    We used the respective lemmas to handle each of the length cases mentioned in our control flow graph.
    At each return point we solve a postcondition (invariant goal) that states the memory at the source and the memory at the destination are the same.
    \clearpage
    
    \chapter{Team Organization}
    Our team consists of 5 people: 
    \begin{itemize}
        \item Adem Odza 
        \begin{itemize}
            \item Initial setup of environment
            \item Created invariants
            \item Modified $memset$ proof statement to fit definition of $memcpy$
            \item Modified $memset$'s $filled$ definition to fit definition of $memcpy$
            \item Created and presented presentation slides
            \item Created \LaTeX~report
        \end{itemize}
        \item Avery Arnold
        \begin{itemize}
            \item Mapping of assembly and CFG graph
            \item Helped with slides and gave presentation
            \item Did the proof and solved length goals
            \item Completed Invariant Goals:
            \begin{itemize}
                \item $8$-$15$ byte copy path
                \item $16$-$32$ byte copy path
            \end{itemize}
            \item Completed Lemmas:
            \begin{itemize}
                \item $filled8$
                \item $filled\_overlap\_16to32bytes$
                \item $filled\_overlap\_8bytes$
                \item $filled\_overlap\_8bytes$
            \end{itemize}
            \item Admitted Lemmas:
            \begin{itemize}
                \item $qword\_subsumes\_bytes\_tail\_16$
                \item $qword\_subsumes\_bytes\_tail$
                \item $filled\_16\_to\_2qwords$
                \item $filled\_8\_to\_qword$
                \item $qwords\_subsume\_bytes\_tail\_32$
            \end{itemize}
        \end{itemize}
        \item Dagmawet Zemedkun
        \begin{itemize}
            \item Mapping of CFG Graph
            \item Tester/Research implementation of connecting k to CPU state
            \begin{itemize}
                \item Modification of $memcpy\_partial\_correctness$
                \item Solved a little over half of the goals
            \end{itemize}
            \item Proved $4$-$7$ byte copy path Invariant:
            \item Completed lemmas:
            \begin{itemize}
                \item $filled1$
                \item $filled2$
                \item $filled\_lt4$
            \end{itemize}
            \item Solved Code/Proved:
            \begin{itemize}
                \item $filled4$
                \item $filled\_succ$
                \item Length proof 
                \begin{itemize}
                    \item $0 < len < 4$
                    \item $4<= len < 8$
                \end{itemize}
            \end{itemize}
            \item Edited/Wrote:
            \begin{itemize}
                \item Final report
                \begin{itemize}
                    \item Connecting k to CPU state under Future Works 
                    \item Evaluations	
                    \item General proof strategy 
                \end{itemize}
                \item filled 
            \end{itemize}
        \end{itemize}
        \item Omar Khan
        \begin{itemize}
            \item Contributed to creating CFG Graph
            \item Mapped out entire binary code in Rocq and documented it in comments
            \item Adjusted lemmas to fix unsolvable goals (mentioned in evaluation section)
            \item Completed Lemmas:
            \begin{itemize}
                \item filled16
                \item $filled3$
                \item $filled3\_pattern$
                \item $filled\_4\_to\_dword$
                \item $filled\_overlap\_4bytes$
                \item $filled\_overlap\_32bytes$
                \item $filled\_overlap\_16to32bytes$
                \item $filled\_overlap\_64bytes\_small$
                \item $filled\_overlap\_64bytes$
                \item $filled\_unaligned\_large$
            \end{itemize}
            \item Admitted Lemmas:
            \begin{itemize}
                \item $filled\_5\_to\_dword$
                \item $filled\_6\_to\_dword$
                \item $filled\_7\_to\_dword$
                \item $filled\_8\_to\_qword$
                \item $filled\_32\_to\_4qwords$
                \item $qwords\_subsume\_bytes\_tail\_32$
                \item $qword\_subsumes\_bytes\_tail\_16$
                \item $filled\_64\_to\_8qwords$
                \item $qwords\_subsume\_bytes\_tail\_64\_small$
                \item $qwords\_subsume\_bytes\_tail\_64$
                \item $unaligned\_qword\_writes\_eq\_filled$
            \end{itemize}
            \item Completed Invariant Goals:
            \begin{itemize}
                \item $< 4$ byte copy path
                \item $32$-$64$ byte copy path
                \item $64$-$128$ byte copy path
                \item $64$-$96$ byte copy path
                \item $64$ byte copy loop path
                \item Large byte copy path
            \end{itemize}

        \end{itemize}
        \item Fatema Tuj Johora
        \begin{itemize}
            \item Formatted and refined presentation slides.
            \item Modified $partial\_correctness$ theorem (later remodified by team).
            \item Attempted byte-wise and $16$–$32$ byte memory copy proofs.
            \item Contributed to \LaTeX~report.
        \end{itemize}
    \end{itemize}

    \clearpage

    \chapter{Evaluation}
    At the beginning of the project, we did not map out the binary code given correctly. 
    This led to creating unnecessary invariants on comparisons and loops of multiple sizes making the proof more complicated. 
    To prevent this issue, we should have, at first, defined the correctness theorem and stepped through the code in Rocq to confirm the behavior. 
    The goals stated in Roqc tell us useful information regarding the addresses of the postcondition and entry loop invariants. 
    This helped us create the invariant set and start proving.

    Another issue we had as a group was taking too much time focusing on the lemmas. 
    Because we did not have the correctness theorem established, we were blindly defining lemmas that may or may not have been useful. 
    As stated previously, we should have defined the main correctness theorem and stepped through the code until we got to an invariant. 
    This made designing a lemma easier since we had all the information in the invariant goal. 

    Even after all these struggles, we were able to prove the partial correctness of $memcpy$. 
    Throughout each goal, we had to define lemmas along the way to make the goal easier to prove. 
    Each lemma that was applied in the main proof was proven, however these lemmas depended on other lemmas which were admitted. 
    The lemmas that were admitted were hard to solve due to complexity and lack of understanding of the Picin\ae~system. 

    As mentioned, we had to admit some lemma due to their complexity.
    The lemmas that gave us trouble were related to the hardware representation of memory in Picin\ae.
    We were able to partially unfold their representation using some of the methods included in the Picin\ae~library.
    We hit the biggest roadblock when we could not fully unfold $setmem$/$getmem$ to match the representation of both consecutive and overlapping writes on the bit level.
    Although we had to forgo solving these lemmas in favor of solving the larger proof structure,
    we are certain that with enough time and a deeper understanding of Picin\ae~and its abstractions, they are possible to solve.

    Along the way, there were some admitted goals relating to length. 
    To solve this issue, we had to adjust the lemmas to make those goals solvable. 
    This was done successfully as we were able to prove that len is less than or equal to $32$, $64$, $96$, and $128$ bytes.

    In an attempt to solve admitted goals pertaining to impossible length comparisons, we implemented a connection between $k$ and the CPU states. 
    This resulted in altering the partial correctness to specifically state that $k$ bytes were copied and adjust the remaining copyable length. 
    This implementation resulted in altering the flow of the proof but it did not solve its intended purpose of impossible to prove length comparisons. 
    After solving more than half of the goals, it was apparent that either lemmas or assertions were still needed to prove length goals. 
    Hence this implementation was set aside and focus was brought back to the current solution.

    Overall, despite a few false starts and redesigns our group made significant progress on this proof.
    We gained valuable insight into the challenge of formally verifying programs related to memory.
    We were able to flush out the main structure of a proof to prove a partial functional correctness of the $memcpy$ program.
    We proved that at each exit point in our program, the bytes at the new destination match the bytes at the source for the length passed to the function.
    The only missing pieces of our proof were a few small lemmas directly related to the functional representation of memory in the Picin\ae~system.
    These lemmas do not affect the overall proof structure or our invariants and require a more fine grained reasoning about the memory model.

    \clearpage

    \chapter{Future Work}
    One thing we would have liked to do if we had more time is prove our few admitted lemmas. 
    In our case these are related directly to the fine grained representation of memory in Picin\ae.

    \section{Connecting K to the CPU State}
    Currently, the solution implemented does not utilize a connection between $k$ and the CPU registers.
    For future work, it is recommended to implement a connection between $k$ and the CPU.
    A small tester implementation was attempted but, due to restriction of time, left uncompleted and voided from final submission of project.
    The core idea of the strategy is to use $k$ as a counter of the bytes that have already been counted.
    A walk-through of the implementation is provided below. \\

    Invariant Set: 
    \begin{lstlisting}
    | 0x100130 => Some (exists k, k <= len /\ memcpy_regs s k)
    \end{lstlisting} 
    \begin{itemize}
        \item Invariant for $k$ bytes copied, where $k <= len$
        \item Present in the final submission version
    \end{itemize}

    Partial Correctness Theorem:
    \begin{itemize}
        \item Original: 
        \begin{itemize}
            \item \begin{lstlisting}
                forall s dest src len mem t s' x' k
                (ENTRY: startof t (x', s') = (Addr 0x100000,s))
                (MDL: models arm8typctx s)
                (MEM: s V_MEM64 = mem)
                (R0: s R_X0 = dest)
                (R1: s R_X1 = src)
                (R2: s R_X2 = len)
                (BOUNDS_DEST: dest + len < 2^64)
                (BOUNDS_SRC : src + len < 2^64)
                (DIST: (dest + len < src) \/ (src + len < dest))
                (K_lim: 0 <= k <= len),
                satisfies_all memcpy_lo_memcpy_armv8
                (memcpy_invset' mem dest src len)
                program_exit
                ((x', s')::t).
            \end{lstlisting}
        \end{itemize}
        \item Updated: 
        \begin{itemize}
            \item \begin{lstlisting}
                forall s dest src len mem t s' x' k
                (ENTRY: startof t (x', s') = (Addr 0x100000,s))
                (MDL: models arm8typctx s)
                (MEM: s V_MEM64 = filled mem dest src k)
                (R0: s R_X0 = dest)
                (R1: s R_X1 = src)
                (R2: s R_X2 = len - k)  
                (K_lim: 0 <= k <= len)
                (BOUNDS_DEST: dest + len < 2^64)
                (BOUNDS_SRC : src + len < 2^64)
                (DIST: (dest + len < src) \/ (src + len < dest)),
                satisfies_all memcpy_lo_memcpy_armv8
                (memcpy_invset' mem dest src len)
                program_exit
                ((x', s')::t).
            \end{lstlisting}
        \end{itemize}
        \item Specific Lines Changed
        \begin{itemize}
            \item The $MEM$ assumption assumes that the memory follows our filled definition, rather than some arbitrary value.
            \item THe $R2$ assumption stats that the $R\_X2$ contains the remaining bytes to copy $(len - k)$ rather than the initial target length.
        \end{itemize}
    \end{itemize}

    
    \section{Results and Discussion}
    A slight variation on how to conduct the proof from previous attempts.
    A negative aspect was that the main issue we were trying to solve: 32 < 32 or other length related impossible goals, were not solved.
    They remained persistent, contributing to the list of reasons this implementation did not survive into the final submission.
    Due to these issues, we did not attempt to prove all goals; we stopped after a little after half of the goals were solved.
    Even though half of the goals were proved, most length related goals were passed with admits.
    This evaluation is only based on the limited implementation that was attempted; further work and editing of theorems and proofs are needed to make full judgement. 




    \clearpage

    \chapter{Related Work}
    Verifying the integrity of memory copies is essential for preventing buffer overflow attacks.
    We took a look at a couple of papers related to this and its impact on the field of research. 
    Specifically, in class we covered a paper on control flow integrity.
    In this work they cover the importance of defined behavior [3].
    In our case, we need to ensure unintended memory behavior did not introduce any security vulnerabilities.
    Our proof of memcpy strives for this goal, as it verifies byte for bytes memory is copied as intended.
    We used such principles to map the control flow of the program, and then prove its correctness for each path via well defined behavior.

    [2] This paper goes into the function input parameters regarding the destination and source address, and data size.
    These repeated memory load and store operations depend on the data size and memory alignment.
    When the source and destination address are properly aligned, larger size memory transfers instructions are used to reduce the number of executed instructions. 
    For small data sizes, memcpy uses byte by byte transfer to ensure correct data copying.

    Averill et al. [4] worked on the formal verification of the \texttt{memset} function. 
    In this report, they have demonstrated partial verification of \texttt{memset}. 
    The verification of \texttt{memcpy} is closely related to \texttt{memset}, as both functions perform iterative writes over contiguous memory regions and preserve memory safety, boundary constraints.
    The only difference is that \texttt{memcpy} copies values from source memory to destination; whereas \texttt{memset} fills a block of memory with a specific byte value.
    Both functions employ block-wise memory writes and follow largely identical control-flow structures, including separate handling of large and small byte writes through similar branching and looping mechanisms.


    \clearpage

    \chapter*{Works Cited}
    \begin{enumerate}[label = {[\arabic*]}]
        \item I. Ghafoor, I. Jattala, S. Durrani and C. Muhammad Tahir, "Analysis of OpenSSL Heartbleed vulnerability for embedded systems," 17th IEEE International Multi Topic Conference $2014$, Karachi, Pakistan, $2014$, pp. $314$-$319$, doi: 10.1109/INMIC.2014.7097358.
        \item H. Ying, H. Zhu, D. Wang and C. Hou, "A novel scheme to generate optimal memcpy assembly code," 2013 IEEE Third International Conference on Information Science and Technology (ICIST), Yangzhou, China, $2013$, pp. $594$-$597$, doi: 10.1109/ICIST.2013.6747619.
        \item M. Abadi, M. Budiu, Ú. Erlingsson, and J. Ligatti, "Control-flow integrity principles, implementations, and applications," ACM Transactions on Information and System Security, vol. $13$, no. $1$, pp. $1$–$40$, Oct. $2009$, doi: \url{https://doi.org/10.1145/1609956.1609960}.
        \item Averill, C., Kadoi, T., Wank, D., \& Harmon, P. $(2023)$. The verification of ARMv7 memset. \url{https://www.charles.systems/writings/The_Verification_of_ARMv7_memset.pdf} 
    \end{enumerate}
\end{document}